\section{LÃ¶sungen}


%%% Graphs

\begin{lsg}
\[ G=(V,E) \text{ mit: } V = \{ 0,1,2,3,4 \}; \]
\[  E = \{(0,1), (0,2), (1,1), (1,2), (2,2), (2,0), (3,1), (3,4), (4,0) \}. \]

\end{lsg}



\begin{lsg}
\hfill


%\begin{figure}[htb]
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick, style=circle]
  \tikzstyle{wstate}=[fill=white,text=black,draw=black]
%  \tikzstyle{gstate}=[fill=gray,text=black,draw=black]
%  \tikzstyle{bstate}=[fill=black,text=white,draw=black]
  
  \node[wstate] 		(6)						{$6$};
  \node[wstate]         (1) [right of=6]		{$1$};
  \node[wstate]         (2) [right of=1]		{$2$};
  \node[wstate]         (3) [below of=6]		{$3$};
  \node[wstate]         (4) [below of=1]		{$4$};
  \node[wstate]         (5) [right of=4]		{$5$};
  \node[wstate]         (0) [above right of=5]	{$0$};

  \path (1) edge              node {} (6)
            edge              node {} (3)
        (2) edge			  node {} (1)
%            edge              node {} (2)
        (3) edge              node {} (4)
            edge [loop below] node {} (3)
        (4) edge 			  node {} (2)
%            edge              node {} (4)
        (5) edge 			  node {} (4);
\end{tikzpicture}
%\caption{Ein weiterer Graph.}
%\label{fig:kont:graph}
\end{center}
%\end{figure}
\end{lsg}



\begin{lsg}
\[A =  \begin{pmatrix}
  0 & 1 & 1 & 0 & 0  \\
  0 & 1 & 1 & 0 & 0  \\
  1 & 0 & 1 & 0 & 0  \\
  0 & 1 & 0 & 0 & 1  \\
  1 & 0 & 0 & 0 & 0  \\
 \end{pmatrix}
  \]
\end{lsg}



\begin{lsg} 
\hfill

%\begin{figure}[htb]
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick, style=circle]
  \tikzstyle{wstate}=[fill=white,text=black,draw=black]
%  \tikzstyle{gstate}=[fill=gray,text=black,draw=black]
%  \tikzstyle{bstate}=[fill=black,text=white,draw=black]
  
%  \node[wstate] 		(6)						{$6$};
  \node[wstate]         (0) [above right of=5]	{$0$};
  \node[wstate]         (1) [right of=0]		{$1$};
  \node[wstate]         (2) [right of=1]		{$2$};
  \node[wstate]         (3) [below of=0]		{$3$};
  \node[wstate]         (4) [below of=1]		{$4$};
  \node[wstate]         (5) [right of=4]		{$5$};
 

  \path (0) edge [loop above]	node {} (0)
  			edge 				node {} (1)
  		(1) edge [bend left]   	node {} (2)
            edge [bend left]   	node {} (4)
        (2) edge [bend left]	node {} (1)
            edge [bend left]   	node {} (5)
            edge 				node {} (4)
        (3) edge             	node {} (0)
%            edge [loop below] 	node {} (3)
        (4) edge [bend left]  	node {} (1)
            edge              	node {} (3)
            edge [loop below]	node {} (4)
        (5) edge 			  	node {} (4)
        	edge [bend left]	node {} (2);
\end{tikzpicture}
%\caption{Ein weiterer Graph.}
%\label{fig:kont:graph}
\end{center}
%\end{figure}
\end{lsg}

\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
def nice_print(graph):
	n = len(graph[0])
	for i in range(n):
		for j in range(n-1):
			print graph[i][j], ";"
		print graph[i][n-1], "\n"
\end{lstlisting}
\end{lsg}




\begin{lsg}
\[ 3: ~ \{1\}; \quad 1: ~ \{2\}~\text{und sich selber}; \quad 0:~\{1,2\} \]
\end{lsg}



\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
def nachbarsknoten(graph, node):
	n = len(graph[0])
	neighbors = []
	for i in range(n):
		if graph[node][i] == 1:
			neighbors.append(i)
	return neighbors
\end{lstlisting}
\end{lsg}


%%%% ENDE INTRO

%%% BEGINN BREITENSUCHE


\begin{lsg}
\textit{Das Vorgehen und der Algorithmus wird in Kapitel \ref{subsec:algorithm}} erl\"autert.
\end{lsg}

\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
def breitensuche (graph, start, ziel):
	n = len(graph[0])
	graueKnoten = [start]
	farben = ['weiss'] * n
	farben[start] = 'grau'
	while graueKnoten != []:
		current = graueKnoten[0]
		if current == ziel:
			print "Distanz: ", distanzen[ziel]
			return True
		for nachbar in nachbarsknoten(graph, current):
			if farben[nachbar] != 'grau' and farben[nachbar] != 'schwarz':
				farben[nachbar] = 'grau'
				graueKnoten += [nachbar]
				distanzen[nachbar] = distanzen[current] + 1
		farben[current] = 'schwarz'
		graueKnoten = graueKnoten[1:]
	return False
\end{lstlisting}
\end{lsg}

\begin{lsg}
\[A =  \begin{pmatrix}
  0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0  \\
  0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0  \\
  0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1  \\
  1 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\
  1 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 1  \\
  0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 1  \\
  0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0  \\
  0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0  \\
  0 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 
 \end{pmatrix}
  \]
\end{lsg}

\begin{lsg}
Es gibt eine Verbindung: das Programm sollte $True$ zur\"uckgeben.
\end{lsg}

\begin{lsg}
Es g\"abe trotzdem noch eine Verbindung zwischen Anna und Jimmy, jedoch nicht zwischen Simon und Tom.
\end{lsg}

\begin{lsg}
Wir speichern die Distanz zu jedem Knoten. Das heisst, der Startknoten bekommt die Distanz 0. Jeder weitere Knoten, der vom aktuellen Knoten aus entdeckt wird (und grau gef\"arbt wird) bekommt die Distanz des aktuellen Knotens plus 1.
\end{lsg}

\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
def breitensuche (graph, start, ziel):
	n = len(graph[0])
	graueKnoten = [start]
	farben = ['weiss'] * n
	farben[start] = 'grau'
	distanzen = [0] * n
	while graueKnoten != []:
		current = graueKnoten[0]
		if current == ziel:
			print "Distanz", distanzen[ziel]
			return True
		for nachbar in nachbarsknoten(graph, current):
			if farben[nachbar] != 'grau' and farben[nachbar] != 'schwarz':
				farben[nachbar] = 'grau'
				graueKnoten += [nachbar]
				distanzen[nachbar] = distanzen[current] + 1
		farben[current] = 'schwarz'
		graueKnoten = graueKnoten[1:]
	return False
\end{lstlisting}
\end{lsg}

\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
def nachbarsknoten(graph, node):
	n = len(graph[0])
	neighbors = []
	for i in range(n):
		if graph[node][i] == 1:
			neighbors.append(i)
	return neighbors

def weg_zum_ziel(vorgaenger, ziel):
	knoten = ziel
	weg = [ziel]	
	while vorgaenger[knoten] != -1:
		weg = [vorgaenger[knoten]] + weg
		knoten = vorgaenger[knoten]
	return weg

def breitensuche (graph, start, ziel):
	n = len(graph[0])
	graueKnoten = [start]
	farben = ['weiss'] * n
	farben[start] = 'grau'
	distanzen = [0] * n
	vorgaenger = [-1] * n
	while graueKnoten != []:
		current = graueKnoten[0]
		if current == ziel:
			print "Distanz", distanzen[ziel]
			print "Weg zum Ziel: ", weg_zum_ziel(vorgaenger, ziel)
			return True
		for nachbar in nachbarsknoten(graph, current):
			if farben[nachbar] != 'grau' and farben[nachbar] != 'schwarz':
				farben[nachbar] = 'grau'
				graueKnoten += [nachbar]
				distanzen[nachbar] = distanzen[current] + 1
				vorgaenger[nachbar] = current
		farben[current] = 'schwarz'
		graueKnoten = graueKnoten[1:]
	return False
\end{lstlisting}
\end{lsg}

\begin{lsg}
Die Stationen werden als Knoten abgebildet, die Linien als Kanten. Da im Kartenausschnitt alle Tramlinien in beide Richtungen befahren werden k\"onnen, k\"onnen wir das Problem als ungerichteten Graphen darstellen.
\end{lsg}

\begin{lsg}
Der Bahnhof Enge ist von der ETH aus auch erreichbar wenn das Bellevue gesperrt ist.
\end{lsg}

\begin{lsg}
\hfill
\begin{enumerate}[(a)]
\item 8
\item 6
\end{enumerate}\end{lsg}

\begin{lsg}
\hfill
\begin{enumerate}[(a)]
\item ETH - Haldenegg - Central - Bahnhofstr. - Rennweg - Paradeplatz - Stockerstr. - Tunnelstr. - Bahnhof Enge
\item ETH - Kantonsschule - Kunsthaus - Bellevue - B\"urkliplatz - Rentenanstalt - Bahnhof Enge
\end{enumerate}\end{lsg}

\begin{lsg}
Bei der Breitensuche kann es sein, dass der ganze Graph traversiert werden muss, um einen Knoten zu finden bzw. um festzustellen, dass er nicht vorhanden ist. Im schlechtesten Fall m\"ussen also alle Knoten und Kanten besucht werden, womit sich die Laufzeit der Breitensuche konzeptionell mit $\mathcal{O}(|V| + |E|)$ beschreiben l\"asst. In unserer Implementation m\"ussen wir jedoch um die Nachbarn eines Knotens zu finden in der Adjazenzmatrix alle anderen Knoten auf eine Verbindung \"uberpr\"ufen, was zu einer Laufzeit von $\mathcal{O}(|V|^2)$ f\"uhrt.
\end{lsg}

\begin{lsg}
Da wir Informationen zu allen Knoten speichern (wie zum Beispiel die Farbe, die Distanz, der Vorg\"angerknoten) bel\"auft sich der Speicherbedarf f\"ur die Breitensuche auf  $\mathcal{O}(|V|)$. Zus\"atzlich dazu braucht das Speichern des Graphen mit einer Adjazenzmatrix $\mathcal{O}(|V|^2)$ Speicherplatz.
\end{lsg}

%%% Graphs



