\section{LÃ¶sungen}


%%% Graphs

\begin{lsg}
\[ G=(V,E) \text{ mit: } V = \{ 0,1,2,3,4 \}; \]
\[  E = \{(0,1), (0,2), (1,2),  (2,0), (3,1), (3,4), (4,0) \}. \]

\end{lsg}



\begin{lsg}
\hfill


%\begin{figure}[htb]
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick, style=circle]
  \tikzstyle{wstate}=[fill=white,text=black,draw=black]
%  \tikzstyle{gstate}=[fill=gray,text=black,draw=black]
%  \tikzstyle{bstate}=[fill=black,text=white,draw=black]
  
  \node[wstate] 		(6)						{$6$};
  \node[wstate]         (1) [right of=6]		{$1$};
  \node[wstate]         (2) [right of=1]		{$2$};
  \node[wstate]         (3) [below of=6]		{$3$};
  \node[wstate]         (4) [below of=1]		{$4$};
  \node[wstate]         (5) [right of=4]		{$5$};
  \node[wstate]         (0) [above right of=5]	{$0$};

  \path (1) edge              node {} (6)
            edge              node {} (3)
        (2) edge			  node {} (1)
%            edge              node {} (2)
        (3) edge              node {} (4)
%            edge [loop below] node {} (3)
        (4) edge 			  node {} (2)
%            edge              node {} (4)
        (5) edge 			  node {} (4)
        (6) edge 			  node {} (3);
\end{tikzpicture}
%\caption{Ein weiterer Graph.}
%\label{fig:kont:graph}
\end{center}
%\end{figure}
\end{lsg}



\begin{lsg}
\[A =  \begin{pmatrix}
  0 & 1 & 1 & 0 & 0  \\
  0 & 0 & 1 & 0 & 0  \\
  1 & 0 & 0 & 0 & 0  \\
  0 & 1 & 0 & 0 & 1  \\
  1 & 0 & 0 & 0 & 0  \\
 \end{pmatrix}
  \]
\end{lsg}



\begin{lsg} 
\hfill

%\begin{figure}[htb]
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick, style=circle]
  \tikzstyle{wstate}=[fill=white,text=black,draw=black]
%  \tikzstyle{gstate}=[fill=gray,text=black,draw=black]
%  \tikzstyle{bstate}=[fill=black,text=white,draw=black]
  
%  \node[wstate] 		(6)						{$6$};
  \node[wstate]         (0) [above right of=5]	{$0$};
  \node[wstate]         (1) [right of=0]		{$1$};
  \node[wstate]         (2) [right of=1]		{$2$};
  \node[wstate]         (3) [below of=0]		{$3$};
  \node[wstate]         (4) [below of=1]		{$4$};
  \node[wstate]         (5) [right of=4]		{$5$};
 

  \path (0) edge 				node {} (1)
		    edge 				node {} (4)
  		(1) edge [bend left]   	node {} (2)
            edge [bend left]   	node {} (4)
        (2) edge [bend left]	node {} (1)
            edge [bend left]   	node {} (5)
            edge 				node {} (4)
        (3) edge             	node {} (0)
%            edge [loop below] 	node {} (3)
        (4) edge [bend left]  	node {} (1)
            edge              	node {} (3)
      %      edge [loop below]	node {} (4)
        (5) edge 			  	node {} (4)
        	edge [bend left]	node {} (2);
\end{tikzpicture}
%\caption{Ein weiterer Graph.}
%\label{fig:kont:graph}
\end{center}
%\end{figure}
\end{lsg}

\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
A = [ [0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [1, 1, 0, 1, 1], 
		[0, 0, 1, 0, 1], [1, 0, 1, 1, 0] ]
print A[1]
print A[2][3]
\end{lstlisting}
%\end{lsg}

Die Ausgabe gibt:
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
[1, 0, 1, 0, 0]
1
\end{lstlisting}
\end{lsg}



\begin{lsg}
Der Knoten 3 hat den Nachbarknoten: 1.

Der Knoten 1 hat den Nachbarknoten: 2.

Der Knoten 0 hat die Nachbarknoten: 1 und 2.
\end{lsg}


\begin{lsg}
Der Knoten 0 hat die Nachbarknoten: 1 und 4.

Der Knoten 2 hat die Nachbarknoten: 0,1 und 3.

Der Knoten 4 hat die Nachbarknoten: 0,2 und 3.

\end{lsg}


\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
def nachbarsknoten(graph, node):
	n = len(graph[0])
	neighbors = []
	for i in range(n):
		if graph[node][i] = = 1:
			neighbors.append(i)
	return neighbors
\end{lstlisting}
\end{lsg}


%%%% ENDE INTRO

%%% BEGINN BREITENSUCHE


\begin{lsg}
Wenn wir beim Startknoten beginnen, m\"ochten wir zuerst alle Knoten absuchen, welche mit minimaler Distanz vom Startknoten aus erreichbar sind, also die direkten Nachbarsknoten vom Startknoten. Wenn wir in k\"urzester Distanz den gesuchten Knoten nicht gefunden haben m\"ussen wir die n\"achste gr\"ossere Distanz in Kauf nehmen, in der Hoffnung, den Knoten dort zu finden. Wenn wir so vorgehen und den Knoten finden wissen wir n\"amlich, dass wir ihn auf dem k\"urzesten m\"oglichen Weg gefunden haben.
\textit{Das Vorgehen und der Algorithmus wird in Kapitel \ref{subsec:algorithm}} detaillierter erl\"autert.
\end{lsg}

\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
def breitensuche (graph, start, ziel):
	if start = = ziel:
		return True
	n = len(graph[0])
	graueKnoten = [start]
	farben = ['weiss'] * n
	farben[start] = 'grau'
	while graueKnoten != []:
		current = graueKnoten[0]
		for nachbar in nachbarsknoten(graph, current):
			if nachbar = = ziel:
				return True
			if farben[nachbar] != 'grau' and farben[nachbar] != 'schwarz':
				farben[nachbar] = 'grau'
				graueKnoten += [nachbar]
		farben[current] = 'schwarz'
		graueKnoten = graueKnoten[1:]
	return False
\end{lstlisting}
\end{lsg}

\begin{lsg}
\[A =  \begin{pmatrix}
  0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0  \\
  0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0  \\
  0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1  \\
  1 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\
  1 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 1  \\
  0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 1  \\
  0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0  \\
  0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0  \\
  0 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 
 \end{pmatrix}
  \]
\end{lsg}

\begin{lsg}
Es gibt eine Verbindung: das Programm sollte $True$ zur\"uckgeben.
\end{lsg}

\begin{lsg}
Es g\"abe trotzdem noch eine Verbindung zwischen Anna und Jimmy, jedoch nicht zwischen Simon und Tom.
\end{lsg}

\begin{lsg}
Wir speichern die Distanz zu jedem Knoten. Das heisst, der Startknoten bekommt die Distanz 0. Jeder weitere Knoten, der vom aktuellen Knoten aus entdeckt wird (und grau gef\"arbt wird) bekommt die Distanz des aktuellen Knotens plus 1.
\end{lsg}

\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
def breitensuche (graph, start, ziel):
	if start = = ziel:
		print "Distanz : ", 0
		return True
	n = len(graph[0])
	graueKnoten = [start]
	farben = ['weiss'] * n
	farben[start] = 'grau'
	distanzen = [-1] * n
	while graueKnoten != []:
		current = graueKnoten.pop(0)
		for nachbar in nachbarsknoten(graph, current):
			if farben[nachbar] != 'grau' and farben[nachbar] != 'schwarz':
				distanzen[nachbar] = distanzen[current] + 1
				if nachbar = = ziel:
					print "Distanz: ", distanzen[ziel]
					return True
				farben[nachbar] = 'grau'
				graueKnoten += [nachbar]
		farben[current] = 'schwarz'
	return False
\end{lstlisting}
\end{lsg}

\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
def weg_zum_ziel(vorgaenger, ziel):
	knoten = ziel
	weg = [ziel]	
	while vorgaenger[knoten] != -1:
		weg = [vorgaenger[knoten]] + weg
		knoten = vorgaenger[knoten]
	return weg
\end{lstlisting}
\end{lsg}

\begin{lsg}
\hfill
\begin{lstlisting}[language=Python,basicstyle=\small,tabsize=3]
def breitensuche (graph, start, ziel):
	if start = = ziel:
		print "Distanz: ", 0
		print "Weg zum Ziel: schon am Ziel!"
		return True
	n = len(graph[0])
	graueKnoten = [start]
	farben = ['weiss'] * n
	farben[start] = 'grau'
	distanzen = [-1] * n
	vorgaenger = [-1] * n
	while graueKnoten != []:
		current = graueKnoten[0]
		for nachbar in nachbarsknoten(graph, current):
			if nachbar = = ziel:
				print "Distanz: ", distanzen[ziel]+1
				print "Weg zum Ziel: ", weg_zum_ziel(vorgaenger, ziel)
				return True
			if farben[nachbar] != 'grau' and farben[nachbar] != 'schwarz':
				distanzen[nachbar] = distanzen[current] + 1
				vorgaenger[nachbar] = current
				farben[nachbar] = 'grau'
				graueKnoten += [nachbar]
		farben[current] = 'schwarz'
		graueKnoten = graueKnoten[1:]
	return False
\end{lstlisting}
\end{lsg}

\begin{lsg}
Die Stationen werden als Knoten abgebildet, die Linien als Kanten. Da im Bild alle Tramlinien in beide Richtungen befahren werden k\"onnen, k\"onnen wir das Problem als ungerichteten Graphen darstellen, mittels folgender Adjazenzmatrix:

  \begin{tabular}{ c | c  c  c  c  c  c  c  c  c  c  c  c  c  c  c |}
  &  \rot{ETH/Universit\"atsspital}  & \rot{Haldenegg} & \rot{Kantonsschule} & \rot{Kunsthaus} &  \rot{Neumarkt} & \rot{Central} & \rot{Rudolf-Brun-Br\"ucke}  &  \rot{Rathaus} & \rot{Helmhaus}  & \rot{Bellevue}  & \rot{B\"urkliplatz}  & \rot{Bahnhofstr./HB}  &  \rot{Rennweg} & \rot{B\"orsenstrasse}  & \rot{Paradeplatz}   \\ \hline
ETH/Universit\"atsspital  & 0 & 1 & 1  & 0  & 0  & 0  & 0  & 0  & 0  & 0  &  0 & 0  & 0  & 0 & 0 \\ 
Haldenegg &  1 &  0 &  0 &  0 &  0 & 1  & 0  & 0  & 0  & 0  & 0  & 0  & 0  & 0  &  0 \\ 
Kantonsschule &  1 & 0 & 0 & 1 & 0  & 0 &  0 & 0  & 0  & 0  & 0  & 0  & 0  & 0  &  0  \\ 
Kunsthaus  & 0  & 0 &  1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
Neumarkt    &  0 &  0 & 0 & 1  & 0 & 1  & 0  & 0  & 0  & 0  & 0  & 0  & 0  &  0 & 0 \\
Central    & 0 &  1 & 0 & 0 &  1 & 0 & 1  & 0  & 0  & 0  & 0 & 1  & 0 &  0  &  0 \\
Rudolf-Brun-Br\"ucke    & 0  & 0  & 0  &  0 & 0 & 1 & 0 & 1 & 0  &  0  &  0 & 0 & 0 & 0 & 0 \\
Rathaus    & 0 & 0 &  0 &  0 & 0  & 0 & 1  & 0 & 1  & 0  & 0  & 0  & 0  &  0  & 0\\
Helmhaus   & 0 & 0 & 0 &  0 &  0 &  0 & 0 &  1 & 0 & 1  &  0 &  0 & 0  & 0 & 0 \\
Bellevue    & 0  & 0  & 0 & 1  &  0 & 0  & 0  & 0 &  1 &  0 & 1 &  0 & 0 &  0   & 0 \\
B\"urkliplatz    &  0 &  0 & 0  & 0  & 0  & 0  & 0  & 0  & 0  &  1 & 0  &  0 & 0  & 1  & 0\\
Bahnhofstr./HB   & 0  & 0  &  0 &  0 & 0  &  1 & 0  & 0  & 0 &  0 & 0  & 0  &  1 &  0   & 0\\
Rennweg    &  0 & 0  & 0  &  0 & 0 & 0  & 0  & 0  & 0  & 0  &  1 & 1 & 0  & 0  &  0 \\
B\"orsenstrasse    & 0  & 0  & 0  & 0  & 0  &0   & 0  & 0  & 0  &  1 & 1 & 0  & 0  & 0  & 0   \\
Paradeplatz    & 0  & 0  &  0 & 0  & 0  & 0  & 0  & 0  & 0  & 0 &  1 & 0  &  1 &  0 & 0  \\ \hline
\end{tabular}
\end{lsg}

\begin{lsg}
Die Adjazenzmatrix \"andert sich so, dass alle Eintr\"age in der Zeile und in der Spalte vom Central 0 werden.

Der Paradeplatz ist von der ETH aus auch erreichbar wenn das Central gesperrt ist, und zwar mit folgendem Weg: ETH - Kantonsschule - Kunsthaus - Bellevue - B\"orsenstrasse - B\"urkliplatz - Paradeplatz.
\end{lsg}

\begin{lsg}
\hfill
\begin{enumerate}[(a)]
\item 7 
\item 6
\end{enumerate}\end{lsg}

\begin{lsg}
\hfill
\begin{enumerate}[(a)]
\item ETH - Kantonsschule - Kunsthaus - Bellevue - B\"urkliplatz - B\"orsenstrasse - Paradeplatz
\item ETH - Haldenegg - Central - Bahnhofstrasse/HB - Rennweg - Paradeplatz
\end{enumerate}\end{lsg}
%%% Graphs



